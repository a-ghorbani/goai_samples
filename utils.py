import numpy as np
import pandas as pd

def cartesian(arrays, out=None):
    """Generate a cartesian product of input arrays.
    Parameters
    ----------
    arrays : list of array-like
        1-D arrays to form the cartesian product of.
    out : ndarray
        Array to place the cartesian product in.
    Returns
    -------
    out : ndarray
        2-D array of shape (M, len(arrays)) containing cartesian products
        formed of input arrays.
    Examples
    --------
    >>> cartesian(([1, 2, 3], [4, 5], [6, 7]))
    array([[1, 4, 6],
           [1, 4, 7],
           [1, 5, 6],
           [1, 5, 7],
           [2, 4, 6],
           [2, 4, 7],
           [2, 5, 6],
           [2, 5, 7],
           [3, 4, 6],
           [3, 4, 7],
           [3, 5, 6],
           [3, 5, 7]])
    """
    for n, arr in enumerate(arrays):
        print(arr)
        print("hello: ",  len(arr))
 
    arrays = [np.asarray(x) for x in arrays]
    shape = (len(x) for x in arrays)
    
    ix = np.indices(shape)
    ix = ix.reshape(len(arrays), -1).T
    if out is None:
        out = pd.DataFrame(columns=['C'+str(i) for i in range(len(arrays))])

    for n, arr in enumerate(arrays):
        out[out.columns[n]] = arrays[n][ix[:, n]]

    return out

def _grid_from_X(X, percentiles=(0.02, 0.98), grid_resolution=100):
    """Generate a grid of points based on the ``percentiles of ``X``.
    The grid is generated by placing ``grid_resolution`` equally
    spaced points between the ``percentiles`` of each column
    of ``X``.
    Parameters
    ----------
    X : ndarray
        The data
    percentiles : tuple of floats
        The percentiles which are used to construct the extreme
        values of the grid axes.
    grid_resolution : int
        The number of equally spaced points that are placed
        on the grid.
    Returns
    -------
    grid : ndarray
        All data points on the grid; ``grid.shape[1] == X.shape[1]``
        and ``grid.shape[0] == grid_resolution * X.shape[1]``.
    axes : seq of ndarray
        The axes with which the grid has been created.
    """
    if len(percentiles) != 2:
        raise ValueError('percentile must be tuple of len 2')
    if not all(0. <= x <= 1. for x in percentiles):
        raise ValueError('percentile values must be in [0, 1]')

    axes = []
    for col in X.columns:
        print(col)
        uniq = X[col].unique()
        if len(uniq) > grid_resolution:
            
            if X[col].dtype.kind == 'O':
                # feature has low resolution use unique vals
                if uniq.dtype.name == 'category':
                    axis = uniq.categories.tolist()
                else:
                    axis = uniq.tolist()
            else:
                q = X[col].quantile(q = percentiles)            
                # create axis based on percentiles and grid resolution
                axis = np.linspace(q.min(),
                                   q.max(),
                                   num=grid_resolution, endpoint=True)

                # convert to int if the original column is int
                if X[col].dtype.kind == 'i':
                    axis = np.round(axis).astype('int')
        else:
            axis = uniq
            if uniq.dtype.name == 'category':
                axis = uniq.categories.tolist()
            else:
                axis = uniq.tolist()
            
        axes.append(axis)

    out = pd.DataFrame(columns=X.columns)
    return cartesian(axes, out), axes